

# This file was *autogenerated* from the file tp6-jazeron.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_7 = Integer(7); _sage_const_6 = Integer(6); _sage_const_5 = Integer(5); _sage_const_4 = Integer(4); _sage_const_11 = Integer(11); _sage_const_10 = Integer(10); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1)
print("""\
# ****************************************************************************
#  FONCTIONS DE SAGEMATH
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

MPol = PolynomialRing(QQ,_sage_const_3 , order='lex', names=('x', 'y', 'z',)); (x, y, z,) = MPol._first_ngens(3)
f = _sage_const_2 *x**_sage_const_2 *y+_sage_const_7 *z**_sage_const_3 

# Code pour l'EXERCICE

print(x<y**_sage_const_2 )
print(f.lt())
print(f.lc())
print(f.lm())

reponse  ="""x est inférieur a y^2 car on utilise l'ordre lexicographique
Par ordre lexicographique, le terme en 2*x^2 est le plus grand car tous les autres n'ont pas de x dedans
Donc le coefficient domimant est 2 et le monôme dominant est x^2"""

# # Affichage des resultats

print("\n$1/ ", reponse)

reset()
print("""\
# ****************************************************************************
# DIVISION MULTIVARIEE
# ****************************************************************************
""")

# Donnees de l'enonce de l'exercice

MPol = PolynomialRing(QQ,_sage_const_2 , order='lex', names=('x', 'y',)); (x, y,) = MPol._first_ngens(2)
f  = -x**_sage_const_7  + x**_sage_const_6 *y + _sage_const_2 *x**_sage_const_5  - _sage_const_2 *x**_sage_const_4 *y - _sage_const_5 *x**_sage_const_2  + _sage_const_3 *x*y**_sage_const_3  + _sage_const_5 *x*y + _sage_const_11 *y**_sage_const_3  + _sage_const_10  
f1 = x*y**_sage_const_2 +_sage_const_2 *y**_sage_const_2 
f2 = x**_sage_const_5 +_sage_const_5 

# Code pour l'EXERCICE

def testDiv(p,F):
    for i in range(len(F)):
        if F[i]!=_sage_const_0 :
            if p.lt()%F[i].lt()==_sage_const_0  :
                return (True,i)
    return (False,-_sage_const_1 )

def myDivision(f,F):
    MPol = f.parent()
    n = MPol.ngens()
    s = len(F)
    Q = [MPol(_sage_const_0 )]*s
    r = MPol(_sage_const_0 )
    p = f
    while p!=MPol(_sage_const_0 ) :
        b,i = testDiv(p,F)
        if b :
            Q[i]= Q[i]+p.lt()//F[i].lt()
            p = p - ((p.lt()//F[i].lt())*F[i])
        else :
            r = r + p.lt()
            p = p - p.lt()
    assert(f==sum(q*g for q,g in zip(Q,F) )+r)
    return Q,r

# # Affichage des resultats

print("\n$ ",  myDivision(f,[f1,f2]))
print("""\
# ****************************************************************************
# BASE DE GROEBNER
# ****************************************************************************
""")

# Donnees de l'enonce de l'exercice

MPol = PolynomialRing(QQ,_sage_const_3 , order='lex', names=('x', 'y', 'z',)); (x, y, z,) = MPol._first_ngens(3)
f1 = x**_sage_const_2 -y
f2 = x*y-z
f3 = z**_sage_const_4 +x*y

# Code pour l'EXERCICE

def myGroebner(F):
    G=F.copy()
    S=[_sage_const_1 ]
    s = lambda g, h : (lcm(g.lt(),h.lt())//g.lt())*g - (lcm(g.lt(),h.lt())//h.lt())*h
    while S :
        S=[]
        for g in G :
            for h in G :
                r = s(g,h)
                _, r = myDivision(r,G)
                if r != _sage_const_0  :
                    S+=[r]
        G+=S
    G=list(set(G))
    return G
         
def testIfRemovableElement(G):
    for i in range(len(G)):
        g = G[i]
        if g.lt() in Ideal([f.lt() for f in G if f!=g]) :
            return (True,i)
    return (False, -_sage_const_1 )
        
    
def myRedGroebner(F):
    G=myGroebner(F)
    b, i = testIfRemovableElement(G)
    while b :
        G.pop(i)
        b, i = testIfRemovableElement(G)
    for i in range(len(G)) :
        G[i]=G[i]/G[i].lc()
    return G
    

def myRedGroebner2(F):
    G=myGroebner(F)
    for i in range(len(G)) :
        g=G[i]
        _, r = myDivision(g,[f for f in G if f!=g])
        if r!=_sage_const_0  :
            G[i]=r/r.lc()
        else:  
            G[i]=r
    i=_sage_const_0 
    while i<len(G):
        if G[i]==_sage_const_0 :
            G.pop(i)
        else :
            i+=_sage_const_1 
    return G
    
# # Affichage des resultats

print("\n$1/ ",myGroebner([f1,f2,f3]))
print("\n$2/ ",myRedGroebner2([f1,f2,f3]))
print("""\
# ****************************************************************************
# APPARTENANCE A UN IDEAL
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

MPol = PolynomialRing(QQ,_sage_const_3 , order='lex', names=('x', 'y', 'z',)); (x, y, z,) = MPol._first_ngens(3)
f1 = x*y-y**_sage_const_2 
f2 = x**_sage_const_3 -z**_sage_const_2 
I = Ideal([f1,f2])
f = -_sage_const_4 *x**_sage_const_2 *y**_sage_const_2 *z**_sage_const_2  + y**_sage_const_6  + _sage_const_3 *z**_sage_const_5 

# Code pour l'EXERCICE

test1 = f in I
_, r = myDivision(f,I.groebner_basis())
test2 = (r==_sage_const_0 ) # A ECRIRE VOUS-MEME


# # Affichage des resultats

print("\n$ Test de Sage ",test1)
print("\n$ Test de personnel ",test2)

reset()
print("""\
# ****************************************************************************
# RESOLUTION D'UN SYSTEME
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice


MPol = PolynomialRing(QQ,_sage_const_2 ,order='lex', names=('x', 'y',)); (x, y,) = MPol._first_ngens(2)# QUEL ORDRE DEVEZ-VOUS CHOISIR ?
f = (y**_sage_const_2 +_sage_const_6 )*(x-_sage_const_1 ) - y*(x**_sage_const_2  + _sage_const_1 )
g = (x**_sage_const_2 +_sage_const_6 )*(y-_sage_const_1 ) - x*(y**_sage_const_2  + _sage_const_1 )
 

# Code pour l'EXERCICE

I = Ideal(f,g)

base = I.groebner_basis() # Vous pouvez utiliser la fonction adhoc de sage
                          # pour calculer la base Groebner
racines_y = [y for (y,_) in base[_sage_const_2 ].univariate_polynomial().roots()] 
racinesf = [(x,racines_y[_sage_const_0 ]) for (x,_) in f.subs({y:racines_y[_sage_const_0 ]}).univariate_polynomial().roots()]+ [(x,racines_y[_sage_const_1 ]) for (x,_) in f.subs({y:racines_y[_sage_const_1 ]}).univariate_polynomial().roots()]
racinesg = [(x,racines_y[_sage_const_0 ]) for (x,_) in g.subs({y:racines_y[_sage_const_0 ]}).univariate_polynomial().roots()]+ [(x,racines_y[_sage_const_1 ]) for (x,_) in g.subs({y:racines_y[_sage_const_1 ]}).univariate_polynomial().roots()]
racinesf = set(racinesf)
racinesg = set(racinesg)
racines  = [(x,y) for (x,y) in racinesf if (x,y) in racinesg]

Gf = implicit_plot(f,(x,_sage_const_0 ,_sage_const_6 ),(y,_sage_const_0 ,_sage_const_6 ),color='red') 
Gg = implicit_plot(g,(x,_sage_const_0 ,_sage_const_6 ),(y,_sage_const_0 ,_sage_const_6 ),color='blue')  
Gp = point2d(racines,color='green')

# # Affichage des resultats

print("\n$1/  Une base de Groebner de [f,g] est", base)
print("\n$2/  Les valeurs de y sont", racines_y)
print("\n$4/  Les valeurs de (x,y) sont", racines)
print("\n$4/")
show(Gf+Gg+Gp)

reset()
print("""\
# ****************************************************************************
# OPTIMISATION
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice


MPol = PolynomialRing(QQ,_sage_const_3 ,order='invlex', names=('x', 'y', 'lamb',)); (x, y, lamb,) = MPol._first_ngens(3)# QUEL ORDRE DEVEZ-VOUS CHOISIR ?
f = x**_sage_const_2 *y  - _sage_const_2 *x*y + y + _sage_const_1 
g = x**_sage_const_2  + y**_sage_const_2  - _sage_const_1 


# Code pour l'EXERCICE

gradf = vector(MPol,[f.derivative(x),f.derivative(y)])
gradg = vector(MPol,[lamb*g.derivative(x),lamb*g.derivative(y)])

print(gradf, gradg)

syst = [gradg[_sage_const_0 ]-gradf[_sage_const_0 ],gradg[_sage_const_1 ]-gradf[_sage_const_1 ],g]
I = Ideal(syst)
base = I.groebner_basis()
racines=[]
x_possibles = [xx  for (xx,_) in base[_sage_const_2 ].univariate_polynomial().roots(RR)]
y_x_possibles = [(xx,yy) for xx in x_possibles for yy,_ in base[_sage_const_1 ].subs({x:xx}).univariate_polynomial().roots(RR)]
racines=[(xx,yy) for (xx,yy) in y_x_possibles for l,_ in base[_sage_const_0 ].subs({x:xx,y:yy}).univariate_polynomial().roots(RR)]
print("\n$1/  On doit resoudre le systeme", syst)
print("\n$2/  dont une base de Groebner est", base)
print("\n$4/  Les valeurs de (x,y) sont", racines)

reset()
print("""\
# ****************************************************************************
# MANIPULATIONS ALGEBRIQUES
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

# Code pour l'EXERCICE
MPol = PolynomialRing(QQ,_sage_const_4 ,order='degrevlex', names=('x', 'y', 'u', 'v',)); (x, y, u, v,) = MPol._first_ngens(4)
# x represente cos(theta), y represente sin(theta)
f1=x+y - u
f2=x**_sage_const_2  - y**_sage_const_2  + _sage_const_2 *x*y - v
f3= x**_sage_const_2  + y**_sage_const_2  - _sage_const_1 
I = Ideal(f1,f2,f3)
formule = I.reduce(y**_sage_const_6 )
# # Affichage des resultats

print("\n$1/ ", formule)

reset()
print("""\
# ****************************************************************************
# OVALES DE DESCARTES
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

MPol = PolynomialRing(QQ,_sage_const_4 ,order='invlex', names=('x', 'y', 'w', 'z',)); (x, y, w, z,) = MPol._first_ngens(4)
f1 = w+_sage_const_2 *z-_sage_const_3 
f2 = w**_sage_const_2  - (x**_sage_const_2  + y**_sage_const_2 )
f3 = z**_sage_const_2  - ((x-_sage_const_1 )**_sage_const_2  + y**_sage_const_2 )
I = Ideal(f1,f2,f3)
base = I.groebner_basis()
# Code pour l'EXERCICE

eq = base[-_sage_const_1 ]

# # Affichage des resultats

MPol2 = PolynomialRing(QQ,_sage_const_2 ,order='lex', names=('x', 'y',)); (x, y,) = MPol2._first_ngens(2)

print("\n$ L'équation est ",eq,"= 0")
implicit_plot(MPol2(eq),(x,-_sage_const_2 ,_sage_const_6 ),(y,-_sage_const_4 ,_sage_const_4 ))

