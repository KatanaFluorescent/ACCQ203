

# This file was *autogenerated* from the file tp5-jazeron.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_10 = Integer(10); _sage_const_100 = Integer(100); _sage_const_9 = Integer(9); _sage_const_6 = Integer(6); _sage_const_5 = Integer(5); _sage_const_4 = Integer(4); _sage_const_13 = Integer(13); _sage_const_12 = Integer(12); _sage_const_7626 = Integer(7626)
print("""\
# *************************************************************************** #
# *************************************************************************** #
# TP5 : FACTORISATION COMPLETE DE POLYNOMES UNIVARIEES                        #
# *************************************************************************** #
# *************************************************************************** #
""")

# CONSIGNES
#
# Les seules lignes a modifier sont annoncee par "Code pour l'exercice"
# indique en commmentaire et son signalees
# Ne changez pas le nom des variables
#
# CONSEILS
#
# Ce modele vous sert a restituer votre travail. Il est deconseille d'ecrire
# une longue suite d'instruction et de debugger ensuite. Il vaut mieux tester
# le code que vous produisez ligne apres ligne, afficher les resultats et
# controler que les objets que vous definissez sont bien ceux que vous attendez.
#
# Vous devez verifier votre code en le testant, y compris par des exemples que
# vous aurez fabrique vous-meme.
#


reset()
print("""\
# ****************************************************************************
# BERLEKAMP
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

F3 = FiniteField(_sage_const_3 )
Pol3 = PolynomialRing(F3, names=('x',)); (x,) = Pol3._first_ngens(1)
f = x**_sage_const_3  - x**_sage_const_2  - _sage_const_1 

# Code pour l'EXERCICE

def PetrBerlekamp(f):
    Pol=f.parent()
    x=Pol.gen()
    p=Pol.base_ring().characteristic()
    q=Pol.base_ring().cardinality()
    n=f.degree()
    Q = zero_matrix(Pol.base_ring(),n)
    for j in range(n):
        vec = (x**j)**q % f
        for i in range(n):
            Q[i,j] = vec[i]
    return Q

def myB(f):
    Pol=f.parent()
    x=Pol.gen()
    p=Pol.base_ring().characteristic()
    q=Pol.base_ring().cardinality()
    n=f.degree()
    Q = PetrBerlekamp(f)
    ker_basis = (Q-identity_matrix(n)).right_kernel().basis()
    k = len(ker_basis)
    j = _sage_const_0 
    retour = [f]
    while len(retour) < k :
        j+=_sage_const_1 
        C = [ff for ff in retour if ff.degree()>_sage_const_1 ]
        for ff in C :
            B = []
            for alpha in Pol.base_ring() :
                a = gcd(ff,Pol(list(ker_basis[j]))-alpha)
                if a.degree() >= _sage_const_1  :
                    B.append(a)
            retour.remove(ff)
            retour+=B
    assert(Set(retour) == Set(g for g,_ in list(f.factor())))
    return retour

def racine_p_polynome(f):
    Pol=f.parent()
    x=Pol.gen()
    p=Pol.base_ring().characteristic()
    q=Pol.base_ring().cardinality()
    u=Pol(_sage_const_0 )
    coeffs = list(f)
    coeffs = coeffs[_sage_const_0 :f.degree()+_sage_const_1 :p]
    for i in range(len(coeffs)):
        u += coeffs[i]**(q/p) * x**i
    assert(u**p==f)
    return u

def myFsFC(f):
    Pol=f.parent()
    x=Pol.gen()
    p=Pol.base_ring().characteristic()
    q=Pol.base_ring().cardinality()
    d = f.degree()
    if d<= _sage_const_0 :
        return []
    elif f.derivative()!=_sage_const_0 :
        i=_sage_const_1 
        L=[]
        t=gcd(f.derivative(),f)
        u = f//t
        while u!=Pol(_sage_const_1 ):
            y = gcd(t,u)
            if i%p!=_sage_const_0  and u//y != Pol(_sage_const_1 ) :
                L.append((u//y,i))
            i+=_sage_const_1 
            u=y
            t=t//y
        if t!= Pol(_sage_const_1 ) :
            LL = myFsFC(racine_p_polynome(t))
            for (s,j) in LL :
                L.append((s,p*j))
    else : 
        LL = myFsFC(racine_p_polynome(f))
        for (s,j) in LL :
            L.append((s,p*j))
    assert(prod([f**e for (f,e) in L ]) == f)
    return L

def myFEDD(f):
    Pol=f.parent()
    x=Pol.gen()
    p=Pol.base_ring().characteristic()
    q=Pol.base_ring().cardinality()
    retour = []
    hi=x
    fi=f
    i=_sage_const_0 
    while fi!=Pol(_sage_const_1 ):
        hi = hi**q % f
        gi = gcd(fi,hi-x)
        retour.append(gi)
        fi = fi//gi
    assert(prod(retour) == f)
    return retour

def myFactor(f):
    Pol=f.parent()
    x=Pol.gen()
    p=Pol.base_ring().characteristic()
    q=Pol.base_ring().cardinality()
    retour = []
    f_sans_carre = myFsFC(f)
    for (g,i) in f_sans_carre :
        g_deg_distinct = myFEDD(g)
        for j in range(len(g_deg_distinct)) :
            if g_deg_distinct[j]!= Pol(_sage_const_1 ) :
                irred = myB(g_deg_distinct[j])
                for u in irred :
                    retour.append((u,i))
    assert(Set(retour) == Set(list(f.factor())))
    return retour

# n est le nombre de tests et Pol l'anneau de polynome sur lequel on teste
def testFacto(n,Pol):
    for _ in range(n):
        f = Pol.random_element(_sage_const_1 ,_sage_const_10 )
        f = f/f[f.degree()] # on retire le coeff dominant, on ne teste que sur des polynomes unitaires
        try : #on utilise le fait qu'on teste a la fin de la fonction que la décomposition est bonne
            myFactor(f)
        except AssertionError :
            return False
    return True

test100=testFacto(_sage_const_100 ,PolynomialRing(FiniteField(_sage_const_9 ),'a')) # on fait 100 tests sur F9

x3 = x**_sage_const_3  % f
x6 = x**_sage_const_6  % f
Q = PetrBerlekamp(f)

b1 = vector(F3,[_sage_const_1 ,_sage_const_0 ,_sage_const_0 ])
b2 = vector(F3,[_sage_const_0 ,_sage_const_1 ,_sage_const_1 ])

L = myB(f)

# # Affichage des resultats


print("\n$1a/ x^3 vaut",x3," et x^6 vaut",x6)
print("La matrice de Petr Berlekamp est")
print(Q)

print("\n$1b/ On a Q * b1 - b1 = ")
print(Q*b1-b1)
print("et Q * b2 - b2 = ")
print(Q*b2-b2)

print("\n$1c/ La factorisation de f est :")
print(L)

print("\n Le résultat de 100 tests sur F9 de la factorisation est : ")
print(test100)

reset()
print("""\
# ****************************************************************************
# RELEVEMENT DE HENSEL
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

PolZZ = PolynomialRing(ZZ, names=('x',)); (x,) = PolZZ._first_ngens(1)
m = _sage_const_5 
f = x**_sage_const_4 -_sage_const_1 
g = x**_sage_const_3 +_sage_const_2 *x**_sage_const_2 -x-_sage_const_2 
h = x-_sage_const_2 
d,ss,tt = xgcd(g,h)
s=PolZZ(ss/mod(d,m)); t=PolZZ(tt/mod(d,m))

# Code pour l'EXERCICE



def polynomeCentre(f,m):
    Pol=f.parent()
    x=Pol.gen()
    retour = Pol([mod(coeff,m).lift_centered() for coeff in list(f)])
    return retour

def reduire_coeffs(f,m):
    Pol=f.parent()
    x=Pol.gen()
    retour = Pol([mod(coeff,m) for coeff in list(f)])
    return retour

def myHensel(f,g,h,s,t,m):
    Pol=f.parent()
    x=Pol.gen()
    e = reduire_coeffs(f-g*h,m**_sage_const_2 )
    q,r = (s*e) // h, (s*e) % h
    q,r = reduire_coeffs(q,m**_sage_const_2 ), reduire_coeffs(r, m**_sage_const_2 )
    g_star = reduire_coeffs(g + t*e + q*g, m**_sage_const_2 )
    h_star = reduire_coeffs(h+r,m**_sage_const_2 )
    b = reduire_coeffs(s*g_star+t*h_star -_sage_const_1 ,m**_sage_const_2 )
    c, d = (s*b) // h_star, (s*b) % h_star
    c, d = reduire_coeffs(c,m**_sage_const_2 ), reduire_coeffs(d, m**_sage_const_2 )
    s_star = reduire_coeffs(s-d, m**_sage_const_2 )
    t_star = reduire_coeffs(t - t*b - c*g_star, m**_sage_const_2 )
    return (polynomeCentre(g_star,m**_sage_const_2 ),polynomeCentre(h_star,m**_sage_const_2 ),polynomeCentre(s_star,m**_sage_const_2 ),polynomeCentre(t_star,m**_sage_const_2 ))

def myHenselItere(f,g,h,s,t,p,l):
    Pol=f.parent()
    x=Pol.gen()
    borne = p**l
    while p < borne :
        g,h,s,t = myHensel(f,g,h,s,t,p)
        p = p**_sage_const_2 
    return g,h

reponseQ5="""\nSi f se factorise en produit de plus de deux facteurs on en isole un (disons g) \
qui soit premier avec les autres,on obtient ainsi un produit de deux facteurs, f=gh, on relève pour\
avoir f=gstar * hstar modulo p^l, puis on factorise hstar modulo p, et récursivement on relève\
 cette factorisation modulo p^l"""

# # Affichage des resultats
print("\n Relèvement modulo 25 de ",f,"= (",g,")*(",h,")")
print(myHensel(f,g,h,s,t,m))
print("\n Relèvement modulo 625 de ",f,"= (",g,")*(",h,")")
print(myHenselItere(f,g,h,s,t,_sage_const_5 ,_sage_const_4 ))
print(reponseQ5)


reset()
print("""\
# ****************************************************************************
# FACTORISATION AVEC LLL
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

p=_sage_const_13 
k=_sage_const_4 
m=p**k

PolZZ = PolynomialRing(ZZ, names=('x',)); (x,) = PolZZ._first_ngens(1)
f = x**_sage_const_4 -x**_sage_const_3 -_sage_const_5 *x**_sage_const_2 +_sage_const_12 *x-_sage_const_6 
Pol13 = PolynomialRing(FiniteField(_sage_const_13 ), names=('x',)); (x,) = Pol13._first_ngens(1)
fhat = Pol13(f) # reduc modulo 13 de f
R = Integers(p**k)
PolR = PolynomialRing(R, names=('x',)); (x,) = PolR._first_ngens(1)# Z/13^4Z[X]
ftilde= PolR(f) # reduco modulo 13^4 de f
alpha=_sage_const_0 
beta=_sage_const_0 
gamma=_sage_const_0 
delta=_sage_const_0 
alphahat=_sage_const_0 
betahat=_sage_const_0 
gammahat=_sage_const_0 
deltahat=_sage_const_0 

u = x+_sage_const_7626 

# Code pour l'EXERCICE

racinesF13 = fhat.roots()
alpha, beta, gamma, delta = racinesF13[_sage_const_0 ][_sage_const_0 ], racinesF13[_sage_const_1 ][_sage_const_0 ], racinesF13[_sage_const_2 ][_sage_const_0 ], racinesF13[_sage_const_3 ][_sage_const_0 ]
racines_Z13puiss4 = ftilde.roots(multiplicities=False)
racines_Z13puiss4 = [racine.lift_centered() for racine in racines_Z13puiss4]
for x in racines_Z13puiss4 :
    if x % _sage_const_13  == alpha :
        alphahat = x
    elif x % _sage_const_13  == beta :
        betahat = x
    elif x % _sage_const_13  == gamma :
        gammahat = x
    elif x % _sage_const_13  == delta :
        deltahat = x

uu = PolR(u)
test = (ftilde % uu == _sage_const_0 )

d = u.degree()
j=_sage_const_3 

x = PolZZ.gen()
L = [u*PolZZ(x**i) for i in range(j-d)] + [m*PolZZ(x**i) for i in range(j)]
M = Matrix(ZZ, len(L), j, [[L[h][i] for i in range(j)] for h in range(len(L))])
LLL_basis = M.LLL()
i=_sage_const_0 
while not(any(LLL_basis[i,:])):
    i+=_sage_const_1 
vecteur_court = list(LLL_basis.row(i))
g = PolZZ(vecteur_court)
fact1 = gcd(g,f)
fact2 = f/fact1

# # Affichage des resultats

print("\n$1a/ Les racines sont", alpha, beta, gamma, delta,"modulo",p)
print("\n$1b/ Les racines sont", alphahat, betahat, gammahat, deltahat,"modulo",m)
print("\n$2a/ On teste que u divise f modulo 13^4 :", test)
print("\n$2b/ On en déduit un facteur de f :", fact1)
print("\n$2c/ Puisque aucune des racines de f dans Z/13^4 ne sont racines dans Z, on en déduit la factorisation de f:")
print("\n f=(",fact1,")*(",fact2,")")

