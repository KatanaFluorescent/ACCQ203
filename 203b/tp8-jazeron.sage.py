

# This file was *autogenerated* from the file tp8-jazeron.sage
from sage.all_cmdline import *   # import sage library

_sage_const_561 = Integer(561); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_10 = Integer(10); _sage_const_500 = Integer(500); _sage_const_20 = Integer(20); _sage_const_3 = Integer(3); _sage_const_1001 = Integer(1001); _sage_const_100000 = Integer(100000); _sage_const_100 = Integer(100); _sage_const_4 = Integer(4); _sage_const_9 = Integer(9); _sage_const_1000 = Integer(1000); _sage_const_5 = Integer(5)
print("""\
# *************************************************************************** #
# *************************************************************************** #
# TP8 : PRIMALITE DES ENTIERS                                                 #
# *************************************************************************** #
# *************************************************************************** #
""")

# CONSIGNES
#
# Les seules lignes a modifier sont annoncee par "Code pour l'exercice"
# indique en commmentaire et son signalees
# Ne changez pas le nom des variables
#
# CONSEILS
#
# Ce modele vous sert a restituer votre travail. Il est deconseille d'ecrire
# une longue suite d'instruction et de debugger ensuite. Il vaut mieux tester
# le code que vous produisez ligne apres ligne, afficher les resultats et
# controler que les objets que vous definissez sont bien ceux que vous attendez.
#
# Vous devez verifier votre code en le testant, y compris par des exemples que
# vous aurez fabrique vous-meme.
#


reset()
print("""\
# ****************************************************************************
# TEST DE RABIN-MILLER 
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

n = _sage_const_561 

# Code pour l'EXERCICE

def testRM(n):
    a = randint(_sage_const_2 ,n-_sage_const_1 )
    m = n-_sage_const_1 
    v = _sage_const_0 
    while m % _sage_const_2  == _sage_const_0  :
        m = m/_sage_const_2 
        v+=_sage_const_1 
    g = gcd(a,n)
    if g > _sage_const_1  :
        return False
    b = a**m % n
    if b == _sage_const_1  :
        return True
    for i in range(_sage_const_1 ,v+_sage_const_1 ) :
        if b**_sage_const_2  % n == _sage_const_1 :
            g = gcd(b+_sage_const_1 ,n)
            if g == _sage_const_1  or  g == n :
                return True
            else :
                return False
        b = b**_sage_const_2  % n
    return False
# # Affichage des resultats

print("Test de la primalite de n=",n,"avec implementation de Rabin-Miller")
print(testRM(n))

print("""\
# ****************************************************************************
#  PERFORMANCES DE RABIN-MILLER
# ****************************************************************************
""")

# Donnees de l'enonce de l'exercice

nmin=_sage_const_10 
nmax=_sage_const_500 
nbtests = _sage_const_10 

# Code pour l'EXERCICE

rep2 = "On a par exemple 15 et 21 qui sont souvent déclarés premiers alors que composés. On constate qu'ils sont en fait produits de deux nombres premiers distincts."
rep3 = "Il faut que 1/4^nbtests < 2^-50, c'est à dire qu'il faut faire au moins 25 tests pour assurer une probabilité d'erreur de au plus 2^-50"

# # Affichage des resultats

print(rep2)
print(rep3)
list_plot( [timeit( 'testRM(n)', number=_sage_const_20 , repeat=_sage_const_3 , seconds=true) for n in range(_sage_const_1001 ,_sage_const_1001 +_sage_const_100000 ,_sage_const_100 ) ])
bar_chart( [_sage_const_1 /nbtests * sum( [testRM(n) for i in range(nbtests)]) for n in range(nmin,nmax)])

reset()
print("""\
# ****************************************************************************
# TEST DE SOLOVAY-STRASSEN 
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

n = _sage_const_561 

# Code pour l'EXERCICE

nmin=_sage_const_10 
nmax=_sage_const_500 
nbtests = _sage_const_10 

def testSS(n):
    if n%_sage_const_2  == _sage_const_0  :
        return False
    a = randint(_sage_const_2 ,n-_sage_const_1 )
    if gcd(a,n) > _sage_const_1  : 
        return False
    g = a**((n-_sage_const_1 )/_sage_const_2 ) %n
    if (jacobi_symbol(a,n)%n) == g :
        return True
    else :
        return False

rep3 = "On a par exemple 15, 25 et 27, qui sont des nombres ayant au plus deux facteurs premiers distincts"
rep4 = "Ici la probabilité de trouver un témoin de Solovay parmi les inversibles modulo n est d'au plus 1/2, donc il faut faire 50 tests pour assurer une probabilité de faux diagnostic inférieure à 2^-50"

# # Affichage des resultats

print("Test de la primalite de n=",n,"avec implementation de Solovay-Strassen")
print(testSS(n))
print(rep3)
print(rep4)

bar_chart( [_sage_const_1 /nbtests * sum( [testSS(n) for i in range(nbtests)]) for n in range(nmin,nmax)])
reset()
print("""\
# ****************************************************************************
# TEST DE LUCAS
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice


# Code pour l'EXERCICE

def testL(n,p,q):
    if n == _sage_const_2  :
        return True
    else :
        delta = p**_sage_const_2  - _sage_const_4 *q
        g = gcd(n,_sage_const_2 *q*delta)
        if g > _sage_const_1  and n > g :
            return False
        elif g == n :
            print("Mauvais choix de p, q")
            return None
        eps = n - jacobi_symbol(delta,n)
        m = eps
        t = _sage_const_0 
        while m%_sage_const_2 ==_sage_const_0  :
            m = m/_sage_const_2 
            t+=_sage_const_1 
        U = [_sage_const_0 ,_sage_const_1 ]
        for i in range(_sage_const_2 ,m+_sage_const_1 ) :
            U.append(p*U[i-_sage_const_1 ]-q*U[i-_sage_const_2 ])
        V = [_sage_const_2 ,p]
        for i in range(_sage_const_2 ,n+_sage_const_1 ) :
            V.append(p*V[i-_sage_const_1 ]-q*V[i-_sage_const_2 ])
        g = gcd(n,U[m])
        if g > _sage_const_1  and n > g :
            return False
        elif g == n :
            return True
        for i in range(_sage_const_0 ,t) :
            g = gcd(n,V[(_sage_const_2 **i)*m])
            if g > _sage_const_1  and n > g :
                return False
            elif g == n :
                return True
        return False

# # Affichage des resultats

for _ in range(_sage_const_1 ):
    n =  ZZ.random_element(_sage_const_2 ,_sage_const_3 )
    print(n.is_prime()==testL(n, _sage_const_4 , _sage_const_9 ))

print("""\
# ****************************************************************************
# TEST DE BAILLIE, POMERANCE, SELFRIDGE ET WAGSTAFF
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

nmax=_sage_const_1000 

# Code pour l'EXERCICE

def suite(k) :
    return (-_sage_const_1 )**k*(_sage_const_2 *k+_sage_const_5 )

def testRabinMillnerAFixe(n,a) :
    m = n-_sage_const_1 
    v = _sage_const_0 
    while m % _sage_const_2  == _sage_const_0  :
        m = m/_sage_const_2 
        v+=_sage_const_1 
    g = gcd(a,n)
    if g > _sage_const_1  :
        return False
    b = pow(Mod(a,n),m)
    if b == _sage_const_1  :
        return True
    for i in range(_sage_const_1 ,v+_sage_const_1 ) :
        if (b**_sage_const_2  % n) == _sage_const_1 :
            g = gcd(b+_sage_const_1 ,n)
            if g == _sage_const_1  or  g == n :
                return True
            else :
                return False
        b = b**_sage_const_2  % n
    return False

def testBPSW(n):
    if n == _sage_const_2  :
        return True
    else :
        if not testRabinMillnerAFixe(n,_sage_const_2 ) :
            return False
        k = _sage_const_0 
        delta = suite(k)
        while jacobi_symbol(delta,n) != - _sage_const_1  :
            k+=_sage_const_1 
            delta = suite(k)
        p, q= _sage_const_1 , (_sage_const_1 -delta)/_sage_const_4 
        if not testL(n,p,q) :
            return False
        return True

# # Affichage des resultats

print(all([ZZ(n).is_prime()==testBPSW(n) for n in range(_sage_const_2 ,nmax+_sage_const_1 )]))


