

# This file was *autogenerated* from the file tp9-jazeron.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_5 = Integer(5); _sage_const_7 = Integer(7); _sage_const_11 = Integer(11); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_10 = Integer(10); _sage_const_12 = Integer(12); _sage_const_222763 = Integer(222763); _sage_const_100 = Integer(100); _sage_const_1323269 = Integer(1323269); _sage_const_1000 = Integer(1000); _sage_const_2886 = Integer(2886)
print("""\
# *************************************************************************** #
# *************************************************************************** #
# TP9 : FACTORISATION DES ENTIERS                                             #
# *************************************************************************** #
# *************************************************************************** #
""")

# CONSIGNES
#
# Les seules lignes a modifier sont annoncee par "Code pour l'exercice"
# indique en commmentaire et son signalees
# Ne changez pas le nom des variables
#
# CONSEILS
#
# Ce modele vous sert a restituer votre travail. Il est deconseille d'ecrire
# une longue suite d'instruction et de debugger ensuite. Il vaut mieux tester
# le code que vous produisez ligne apres ligne, afficher les resultats et
# controler que les objets que vous definissez sont bien ceux que vous attendez.
#
# Vous devez verifier votre code en le testant, y compris par des exemples que
# vous aurez fabrique vous-meme.
#


reset()
print("""\
# ****************************************************************************
# DIVISEURS SUCCESSIFS
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

n=_sage_const_2 *_sage_const_3 *_sage_const_3 *_sage_const_5 *_sage_const_5 *_sage_const_5 *_sage_const_7 *_sage_const_11 *_sage_const_11 

# Code pour l'EXERCICE

def div_successives(n):
    F = set()
    d = _sage_const_2 
    while d**_sage_const_2  <= n :
        while n % d == _sage_const_0  :
            n = n/d
            F.add(d)
        d+=_sage_const_1 
    if n != _sage_const_1  :
        F.add(n)
    return list(F)

# # Affichage des resultats

print(div_successives(n))
for n in range(_sage_const_2 ,_sage_const_10 ):
    assert(div_successives(ZZ(n))==ZZ(n).prime_divisors())


reset()
print("""\
# ****************************************************************************
# FACTORISATION D'UN NOMBRE B-FRIABLE
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

n=_sage_const_2 *_sage_const_3 *_sage_const_3 *_sage_const_5 *_sage_const_5 *_sage_const_5 *_sage_const_7 *_sage_const_11 *_sage_const_11 
P=[p for p in primes(_sage_const_12 )]

# Code pour l'EXERCICE

def div_successives_friable(n, P):
    F = set()
    for p in P :
        while n % p == _sage_const_0  :
            n = n/p
            F.add(p)
    return list(F)

# # Affichage des resultats

print(div_successives_friable(n,P))
for n in range(_sage_const_2 ,_sage_const_10 ):
    assert(div_successives_friable(ZZ(n),P)==ZZ(n).prime_divisors())


reset()
print("""\
# ****************************************************************************
# RHO DE POLLARD
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

n=_sage_const_222763 

# Code pour l'EXERCICE

def myPollardrho(n):
    x=Integer(Integers(n).random_element())
    y = x
    f = lambda x : (x**_sage_const_2  + _sage_const_1 ) % n
    x = f(x)
    y = f(f(y))
    g = gcd(x-y,n)
    while g <= _sage_const_1  :
        x = f(x)
        y = f(f(y))
        g = gcd(x-y,n)
    if g == n :
        return "Echec"
    else : 
        return f"{g} est un facteur"

# # Affichage des resultats

print(myPollardrho(n))

for _ in range(_sage_const_5 ):
    n=ZZ.random_element(_sage_const_3 ,_sage_const_100 )
    print(n)
    print(n, 
      "| Resultat rho de Pollard : ", 
      myPollardrho(n), 
      " | n est-il composé ?",not n.is_prime())




reset()
print("""\
# ****************************************************************************
# P-1 DE POLLARD
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

n=_sage_const_1323269 

# Code pour l'EXERCICE

def myPollardpm1(n,b):
    a = randint(_sage_const_2 ,n-_sage_const_1 )
    g = gcd(n,a)
    if g > _sage_const_1  : 
        return f"{g} est un facteur"
    for p in primes(b) :
        alpha = _sage_const_1  
        while p**alpha <= b :
            alpha+=_sage_const_1 
        for j in range(_sage_const_1 ,alpha):
            a = a**p % n
    g = gcd(a-_sage_const_1 ,n)
    if g > _sage_const_1  and g < n :
        return f"{g} est un facteur"
    else :
        return "Echec"


# # Affichage des resultats

myPollardpm1(n,_sage_const_1000 )

for _ in range(_sage_const_5 ):
    n=ZZ.random_element(_sage_const_3 ,_sage_const_100 )
    print(n, 
      "| Resultat rho de Pollard : ", 
      myPollardpm1(n,_sage_const_100 ), 
      " | n est-il composé ?",not n.is_prime())




reset()
print("""\
# ****************************************************************************
# CRIBLE QUADRATIQUE
# ****************************************************************************
""")


# Donnees de l'enonce de l'exercice

n=_sage_const_2886 

# Code pour l'EXERCICE

def cribleQuadratique (n):
    B = ceil(exp(sqrt(ln(n)*ln(ln(n)))))
    premiers = set(primes(B))
    m = len(premiers)
    count = _sage_const_0 
    friables = []
    x = ceil(sqrt(n))
    while True :
        a = x**_sage_const_2  % n
        if a != _sage_const_0  :
            facteurs = prime_divisors(a)
            if all([p in premiers for p in facteurs]) :
                friables.append((x,a))
                count+=_sage_const_1 
            if count == m+_sage_const_1  :
                break
        x+=_sage_const_1 
    
    M = matrix(ZZ,m,len(friables))

    for i in range(len(friables)) :
        (x,a) = friables[i]
        liste_premier = list(premiers)
        for j in range(len(liste_premier)) :
            M[j,i] = _sage_const_0 
            while (a % liste_premier[j]) == _sage_const_0  :
                M[j,i]+=_sage_const_1 
                a = a/liste_premier[j]
    
    M_F2 = matrix(FiniteField(_sage_const_2 ),M)
    v = M_F2.right_kernel().basis()[_sage_const_0 ]
    support = []
    for i in range(len(friables)) :
        if v[i] != _sage_const_0  :
            support.append(i)
    z = _sage_const_1  
    for i in support :
        x,a = friables[i]
        z = z*x % n
    y = _sage_const_1  
    for i in range(m) :
        somme = _sage_const_0 
        for j in support :
            somme += M[i,j]
        somme = somme/_sage_const_2 
        y = ((liste_premier[i]**somme) * y) % n
    d = gcd(z-y,n)
    return d
                
# # Affichage des resultats

print(cribleQuadratique(n))

